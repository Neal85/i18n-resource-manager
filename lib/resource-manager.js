// Generated by CoffeeScript 1.7.1

/*
@author      Created by Haiwei Li <haiwei8086@gmail.com> on 2014-6-8.
@link        https://github.com/haiwei8086/i18n-resource-manager
@license     http://opensource.org/licenses/MIT
@version     0.0.1
 */

(function() {
  var ResourceManager, ResourceOptions, ResourceType, ResourceUtils, Utils, fs, path;

  path = require('path');

  fs = require('fs');

  Utils = require('./utils');

  ResourceType = {
    "OVERRIDE": "Override",
    "APPEND": "Append",
    "PROPERTIES": "Properties"
  };

  ResourceOptions = function() {
    this.key = {
      platform: '_default',
      subPlatform: '_default',
      country: '_default',
      flag: 'null',
      resourceType: ResourceType.OVERRIDE
    };
    this.phyPath = process.cwd();
    this.rules = ['_default/country/_default', '_default/country/{country}', '_default/{subPlatform}/country/_default', '_default/{subPlatform}/country/{country}', '{platform}/country/_default', '{platform}/country/{country}', '{platform}/{subPlatform}/country/_default', '{platform}/{subPlatform}/country/{country}'];
    return this;
  };

  ResourceManager = (function() {
    ResourceManager.prototype.RESOURCE_KEY = "localization-resource";

    function ResourceManager(options) {
      var resource, rulesCache;
      this.options = options;
      this.resourceUtils = new ResourceUtils();
      this.options.rules = this.resourceUtils.resolveRules(this.options);
      this.indexKey = this.resourceUtils.resolveKey(this.options.key);
      rulesCache = this.resourceUtils.buildRules(this.options);
      resource = global[this.RESOURCE_KEY] = {};
      resource[this.indexKey] = rulesCache;
    }


    /*
    Arguments:
    1: (filename) /index.html
    2: (folder..., filename) /part/view.html or /part/view/template.html
     */

    ResourceManager.prototype.get = function() {
      var i, item, key, prefix, _i, _len, _ref;
      key = "";
      prefix = "";
      if (arguments.length > 1) {
        for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
          item = arguments[i];
          if (i + 1 === arguments.length) {
            break;
          }
          prefix += item + "-";
        }
      }
      if (arguments.length > 0) {
        key = prefix + arguments[arguments.length - 1];
      } else {
        return null;
      }
      return (_ref = global[this.RESOURCE_KEY][this.indexKey]) != null ? _ref[key] : void 0;
    };

    ResourceManager.prototype.getCache = function() {
      return global[this.RESOURCE_KEY][this.indexKey];
    };

    ResourceManager.prototype.getIndexKey = function() {
      return this.indexKey;
    };

    ResourceManager.prototype.getOptions = function() {
      return this.options;
    };

    return ResourceManager;

  })();

  ResourceUtils = (function() {
    function ResourceUtils() {}

    ResourceUtils.prototype.resolveRules = function(opts) {
      var item, key, p, reg, results, rule, rules, _i, _len;
      results = new Array();
      key = opts.key;
      rules = opts.rules;
      for (_i = 0, _len = rules.length; _i < _len; _i++) {
        item = rules[_i];
        rule = item;
        for (p in key) {
          reg = new RegExp('({' + p + '})', 'g');
          rule = rule.replace(reg, key[p]);
        }
        if (rule.indexOf('{') !== -1 || rule.indexOf('}') !== -1) {
          throw new Error('Resolve rules error! rule: ' + item);
        }
        results.push(path.normalize(rule));
      }
      return results;
    };

    ResourceUtils.prototype.resolveKey = function(key) {
      var p, result;
      result = "";
      for (p in key) {
        if (result !== "") {
          result += "-";
        }
        result += key[p];
      }
      return result;
    };

    ResourceUtils.prototype.buildRules = function(options) {
      var filesDic;
      if (options.key.resourceType === ResourceType.OVERRIDE || options.key.resourceType === ResourceType.APPEND) {
        return this.buildFilesByRules(options);
      } else if (options.key.resourceType === ResourceType.PROPERTIES) {
        filesDic = this.buildFilesByRules(options);
        return this.buildProperties(options, filesDic);
      } else {
        throw new Error('Resource type invalid! Please check your options.resourceType.');
      }
    };

    ResourceUtils.prototype.buildFilesByRules = function(opts) {
      var folderPhyPath, i, relativePath, results, _i, _len, _ref;
      results = {};
      _ref = opts.rules;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        relativePath = _ref[i];
        folderPhyPath = path.join(opts.phyPath, relativePath);
        if (fs.existsSync(folderPhyPath)) {
          this.buildFilesByDirectory(opts, results, folderPhyPath, relativePath, null);
        }
      }
      return results;
    };

    ResourceUtils.prototype.buildFilesByDirectory = function(opts, files, folderPath, relativePath, prefix) {
      var childes, fName, fStat, i, isExists, item, itemPhyPath, itemRelativePath, rule, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      childes = fs.readdirSync(folderPath);
      _results = [];
      for (i = _i = 0, _len = childes.length; _i < _len; i = ++_i) {
        fName = childes[i];
        itemPhyPath = path.join(folderPath, fName);
        itemRelativePath = path.join(relativePath, fName);
        _ref = opts.rules;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          item = _ref[_j];
          if (item.replace(path.sep) === itemRelativePath.replace(path.sep)) {
            rule = item;
          }
        }
        if (rule !== void 0) {
          continue;
        }
        fName = prefix ? prefix + '-' + fName : fName;
        fStat = fs.statSync(itemPhyPath);
        if (fStat.isFile()) {
          if (typeof files[fName.toLowerCase()] !== "undefined") {
            if (opts.key.resourceType === ResourceType.OVERRIDE) {
              _results.push(files[fName.toLowerCase()] = itemRelativePath);
            } else {
              _ref1 = files[fName.toLowerCase()];
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                item = _ref1[_k];
                if (item === itemRelativePath) {
                  isExists = item;
                }
              }
              if (!isExists) {
                _results.push(files[fName.toLowerCase()].push(itemRelativePath));
              } else {
                _results.push(void 0);
              }
            }
          } else {
            if (opts.key.resourceType === ResourceType.OVERRIDE) {
              _results.push(files[fName.toLowerCase()] = itemRelativePath);
            } else {
              _results.push(files[fName.toLowerCase()] = [itemRelativePath]);
            }
          }
        } else if (fStat.isDirectory()) {
          if (fs.existsSync(folderPath)) {
            _results.push(this.buildFilesByDirectory(opts, files, itemPhyPath, itemRelativePath, fName));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ResourceUtils.prototype.buildProperties = function(opts, filesDic) {
      var filename, files, result;
      result = {};
      for (filename in filesDic) {
        files = filesDic[filename];
        if (path.extname(filename).toLowerCase() === ".json") {
          result[filename] = this.JSONFilesParse(files, opts.phyPath);
        } else {
          result[filename] = this.propertyFilesParse(files, opts.phyPath);
        }
      }
      return result;
    };

    ResourceUtils.prototype.JSONFilesParse = function(files, phyPath) {
      var data, f, obj, result, _i, _len;
      result = null;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        data = fs.readFileSync(path.join(phyPath, f), {
          encoding: "utf8"
        });
        obj = JSON.parse(data);
        result = result === null ? obj : Utils.FillObject(result, obj, "full");
      }
      return result;
    };

    ResourceUtils.prototype.propertyFilesParse = function(files, phyPath) {
      var data, f, fileObj, result, _i, _len;
      result = null;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        data = fs.readFileSync(path.join(phyPath, f), {
          encoding: "utf8"
        });
        fileObj = this.propertyFileToJSON(data);
        result = result === null ? fileObj : Utils.FillObject(result, fileObj, "full");
      }
      return result;
    };

    ResourceUtils.prototype.propertyFileToJSON = function(fileData) {
      var c, i, key, keyArr, kv, line, lineArr, result, subKey, value, _i, _j, _len, _len1;
      result = {};
      lineArr = fileData.toString().split('\r\n');
      for (_i = 0, _len = lineArr.length; _i < _len; _i++) {
        line = lineArr[_i];
        line = line.trim();
        if (line[0] === "#") {
          continue;
        }
        if (line.indexOf('=') === -1) {
          continue;
        }
        kv = line.split('=');
        key = kv[0].trim();
        value = kv[1].trim();
        if (key.indexOf('.') === -1) {
          result[key] = value;
        } else {
          keyArr = key.split('.');
          c = result;
          for (i = _j = 0, _len1 = keyArr.length; _j < _len1; i = ++_j) {
            subKey = keyArr[i];
            if (subKey.trim() === "") {
              continue;
            }
            if (typeof c[subKey] === "undefined") {
              c[subKey] = {};
            }
            if (i + 1 === keyArr.length) {
              c[subKey] = value;
            } else {
              c = c[subKey];
            }
          }
        }
        return result;
      }
    };

    return ResourceUtils;

  })();

  exports.ResourceType = ResourceType;

  exports.ResourceOptions = ResourceOptions;

  exports.ResourceManager = ResourceManager;

}).call(this);

//# sourceMappingURL=resource-manager.map
